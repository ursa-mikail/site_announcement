<!DOCTYPE html>
<html style="height: 100%">
<head>
  <meta charset="UTF-8">
  <title>Emotions Tree</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.13.2/jquery-ui.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.13.2/themes/base/jquery-ui.min.css">
  <style>
    #main {
      height: 100%;
      width: 100%;
    }
    #search-container {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      background-color: white;
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 4px;
    }
    #autocomplete {
      padding: 5px;
      width: 200px;
    }
  </style>
</head>
<body style="height: 100%; margin: 0">
  <div id="search-container">
    <input id="autocomplete" type="text" placeholder="Search Emotions...">
  </div>
  <div id="main"></div>
  
  <script>
    const myChart = echarts.init(document.getElementById('main'));
    myChart.showLoading();

    function processData(csvData) {
      const lines = csvData.split('\n');
      const root = {
        name: 'Emotions',
        children: []
      };
      
      const emotionsSet = new Set();
      const emotionsMap = new Map();
      
      lines.forEach(line => {
        const emotions = line.split(',')
          .map(e => e.trim())
          .filter(e => e.length > 0);
          
        if (emotions.length === 0) return;
        
        emotions.forEach(emotion => {
          emotionsSet.add(emotion);
          if (!emotionsMap.has(emotion)) {
            emotionsMap.set(emotion, {
              name: emotion,
              children: []
            });
          }
        });

        // Create parent-child relationships
        for (let i = 0; i < emotions.length - 1; i++) {
          const parentEmotion = emotionsMap.get(emotions[i]);
          const childEmotion = emotionsMap.get(emotions[i + 1]);
          
          // Check if this child is already present
          if (!parentEmotion.children.some(child => child.name === childEmotion.name)) {
            parentEmotion.children.push(childEmotion);
          }
        }

        // Add first level emotions to root
        if (emotions[0]) {
          const firstEmotion = emotionsMap.get(emotions[0]);
          if (!root.children.some(child => child.name === firstEmotion.name)) {
            root.children.push(firstEmotion);
          }
        }
      });

      // Setup autocomplete
      $("#autocomplete").autocomplete({
        source: Array.from(emotionsSet),
        select: function(event, ui) {
          const selectedEmotion = ui.item.value;
          highlightNode(selectedEmotion);
        }
      });

      return root;
    }

    function highlightNode(emotionName) {
      myChart.dispatchAction({
        type: 'highlight',
        seriesName: 'Emotions',
        name: emotionName
      });
      
      myChart.dispatchAction({
        type: 'showTip',
        seriesName: 'Emotions',
        name: emotionName
      });
    }

    fetch('https://raw.githubusercontent.com/ursa-mikail/emotions_clusters/refs/heads/main/emotions_clusters.csv')
      .then(response => response.text())
      .then(csvData => {
        const treeData = processData(csvData);
        myChart.hideLoading();
        
        const option = {
          tooltip: {
            trigger: 'item',
            triggerOn: 'mousemove'
          },
          series: [{
            type: 'tree',
            name: 'Emotions',
            data: [treeData],
            top: '5%',
            left: '7%',
            bottom: '5%',
            right: '20%',
            symbolSize: 7,
            label: {
              position: 'left',
              verticalAlign: 'middle',
              align: 'right',
              fontSize: 12
            },
            leaves: {
              label: {
                position: 'right',
                verticalAlign: 'middle',
                align: 'left'
              }
            },
            emphasis: {
              focus: 'descendant'
            },
            expandAndCollapse: true,
            animationDuration: 550,
            animationDurationUpdate: 750,
            initialTreeDepth: 2,
            orient: 'LR',
            layout: 'orthogonal'
          }]
        };

        myChart.setOption(option);
      });

    window.addEventListener('resize', () => {
      myChart.resize();
    });
  </script>
</body>
</html>