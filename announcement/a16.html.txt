<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSA/ECDSA Key Management and Signing</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsrsasign/10.9.0/jsrsasign-all-min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 2rem auto;
            padding: 1rem;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .section {
            margin: 1.5rem 0;
            padding: 1.5rem;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }
        textarea, input[type="text"] {
            width: 100%;
            padding: 0.5rem;
            margin: 0.5rem 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
        }
        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            margin: 0.5rem 0.5rem 0.5rem 0;
        }
        button:hover {
            background: #0052a3;
        }
        .success {
            color: #28a745;
            padding: 0.5rem;
            margin: 0.5rem 0;
            display: none;
        }
        .error {
            color: #dc3545;
            padding: 0.5rem;
            margin: 0.5rem 0;
            display: none;
        }
        .file-input {
            margin: 1rem 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>RSA/ECDSA Key Management and Signing</h2>
        
        <div class="section">
            <h3>Step 1: Load and Encrypt Private Key</h3>
            <div class="file-input">
                <label for="private-key-file">Load Private Key (PEM):</label><br>
                <input type="file" id="private-key-file" accept=".pem" onchange="loadPrivateKeyFile()">
            </div>
            <div class="file-input">
                <label for="public-key-file">Load Public Key (PEM):</label><br>
                <input type="file" id="public-key-file" accept=".pem" onchange="loadPublicKeyFile()">
            </div>
            <button onclick="encryptPrivateKey()">Generate AES Key and Encrypt</button>
            
            <h4>Generated AES Key (save this securely):</h4>
            <input type="text" id="aes-key-display" readonly>
            <button onclick="copyToClipboard('aes-key-display')">Copy AES Key</button>
            
            <h4>Encrypted Private Key:</h4>
            <textarea id="encrypted-private-key" rows="4" readonly></textarea>
            <button onclick="copyToClipboard('encrypted-private-key')">Copy Encrypted Key</button>
            <button onclick="downloadText('encrypted-private-key', 'private_key.ciphered.pem')">Download</button>
            <div id="encrypt-success" class="success">Encryption successful!</div>
            <div id="encrypt-error" class="error">Encryption failed. Please check your input.</div>
        </div>

        <div class="section">
            <h3>Step 2: Load and Decrypt Private Key</h3>
            <div class="file-input">
                <label for="encrypted-key-file">Load Encrypted Private Key:</label><br>
                <input type="file" id="encrypted-key-file" accept=".pem" onchange="loadEncryptedKeyFile()">
            </div>
            <textarea id="encrypted-key-input" rows="4" placeholder="Or paste encrypted private key here"></textarea>
            
            <label for="aes-key">Enter AES Key:</label>
            <input type="text" id="aes-key" placeholder="Enter your AES key">
            <button onclick="decryptAndVerify()">Decrypt and Verify</button>
            <div id="decrypt-success" class="success">Decryption and verification successful!</div>
            <div id="decrypt-error" class="error">Decryption failed or verification failed. Please check your keys.</div>
        </div>

        <div class="section">
            <h3>Step 3: Sign Message</h3>
            <label for="message">Enter Message to Sign:</label>
            <textarea id="message" rows="4" placeholder="Enter your message here"></textarea>
            <button onclick="signMessage()">Sign Message</button>
            
            <h4>Signed Message:</h4>
            <textarea id="signed-message" rows="6" readonly></textarea>
            <button onclick="copyToClipboard('signed-message')">Copy Signed Message</button>
            <button onclick="downloadText('signed-message', 'permit.signed.txt')">Download</button>
            <div id="sign-success" class="success">Message signed successfully!</div>
            <div id="sign-error" class="error">Signing failed. Please ensure private key is loaded.</div>
        </div>
    </div>

    <script>
        let currentPrivateKey = null;
        let currentPublicKey = null;
        let keyType = null; // 'RSA' or 'ECDSA'

        function showMessage(elementId, show = true) {
            const element = document.getElementById(elementId);
            element.style.display = show ? 'block' : 'none';
            if (show) {
                setTimeout(() => { element.style.display = 'none'; }, 3000);
            }
        }

        function generateSecureRandomBytes(length) {
            return CryptoJS.lib.WordArray.random(length);
        }

        async function loadPrivateKeyFile() {
            const fileInput = document.getElementById('private-key-file');
            const file = fileInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const pemContent = e.target.result;
                        // Determine key type
                        if (pemContent.includes('BEGIN RSA PRIVATE KEY')) {
                            keyType = 'RSA';
                        } else if (pemContent.includes('BEGIN EC PRIVATE KEY')) {
                            keyType = 'ECDSA';
                        } else {
                            throw new Error('Unsupported key type');
                        }
                        currentPrivateKey = pemContent;
                    } catch (error) {
                        console.error('Error loading private key:', error);
                        showMessage('encrypt-error');
                    }
                };
                reader.readAsText(file);
            }
        }

        async function loadPublicKeyFile() {
            const fileInput = document.getElementById('public-key-file');
            const file = fileInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    currentPublicKey = e.target.result;
                };
                reader.readAsText(file);
            }
        }

        async function encryptPrivateKey() {
            try {
                if (!currentPrivateKey || !currentPublicKey) {
                    throw new Error("Please load both private and public keys");
                }

                // Generate a secure random 256-bit AES key
                const aesKey = generateSecureRandomBytes(32);
                const aesKeyBase64 = aesKey.toString(CryptoJS.enc.Base64);
                const iv = generateSecureRandomBytes(16);

                // Encrypt the private key
                const encrypted = CryptoJS.AES.encrypt(currentPrivateKey, aesKey, {
                    iv: iv,
                    padding: CryptoJS.pad.Pkcs7,
                    mode: CryptoJS.mode.CBC
                });

                // Combine IV and ciphertext
                const encryptedMessage = iv.concat(encrypted.ciphertext).toString(CryptoJS.enc.Base64);

                document.getElementById('aes-key-display').value = aesKeyBase64;
                document.getElementById('encrypted-private-key').value = encryptedMessage;

                showMessage('encrypt-success');
                showMessage('encrypt-error', false);
            } catch (error) {
                console.error('Encryption failed:', error);
                showMessage('encrypt-success', false);
                showMessage('encrypt-error');
            }
        }

        async function loadEncryptedKeyFile() {
            const fileInput = document.getElementById('encrypted-key-file');
            const file = fileInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    document.getElementById('encrypted-key-input').value = e.target.result;
                };
                reader.readAsText(file);
            }
        }

        async function decryptAndVerify() {
            try {
                const aesKeyBase64 = document.getElementById('aes-key').value.trim();
                const encryptedData = document.getElementById('encrypted-key-input').value.trim();

                if (!aesKeyBase64 || !encryptedData) {
                    throw new Error("AES key and encrypted data required");
                }

                // Convert from Base64
                const encryptedWords = CryptoJS.enc.Base64.parse(encryptedData);
                const iv = CryptoJS.lib.WordArray.create(encryptedWords.words.slice(0, 4));
                const ciphertext = CryptoJS.lib.WordArray.create(encryptedWords.words.slice(4));

                // Decrypt
                const decrypted = CryptoJS.AES.decrypt(
                    { ciphertext: ciphertext },
                    CryptoJS.enc.Base64.parse(aesKeyBase64),
                    { iv: iv, padding: CryptoJS.pad.Pkcs7, mode: CryptoJS.mode.CBC }
                );

                const decryptedPem = decrypted.toString(CryptoJS.enc.Utf8);

                // Verify key pair
                const sig = new KJUR.crypto.Signature({ "alg": keyType === "RSA" ? "SHA256withRSA" : "SHA256withECDSA" });
                sig.init(decryptedPem);
                sig.updateString("test");
                const testSig = sig.sign();

                // Verify with public key
                const verifier = new KJUR.crypto.Signature({ "alg": keyType === "RSA" ? "SHA256withRSA" : "SHA256withECDSA" });
                verifier.init(currentPublicKey);
                verifier.updateString("test");
                const isValid = verifier.verify(testSig);

                if (isValid) {
                    currentPrivateKey = decryptedPem;
                    showMessage('decrypt-success');
                    showMessage('decrypt-error', false);
                } else {
                    throw new Error("Key verification failed");
                }
            } catch (error) {
                console.error('Decryption/verification failed:', error);
                showMessage('decrypt-success', false);
                showMessage('decrypt-error');
                currentPrivateKey = null;
            }
        }

        function getTimestamp() {
            const now = new Date();
            const pad = (n) => n.toString().padStart(2, '0');
            return `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}_` +
                   `${pad(now.getHours())}${pad(now.getMinutes())}_${pad(now.getSeconds())}`;
        }

        async function signMessage() {
            try {
                if (!currentPrivateKey) {
                    throw new Error("Private key not loaded");
                }
                
                const message = document.getElementById('message').value.trim();
                if (!message) {
                    throw new Error("Message is required");
                }

                const timestamp = getTimestamp();
                const messageToSign = `${message}\nTimestamp: ${timestamp}`;

                // Sign the message
                const sig = new KJUR.crypto.Signature({ "alg": keyType === "RSA" ? "SHA256withRSA" : "SHA256withECDSA" });
                sig.init(currentPrivateKey);
                sig.updateString(messageToSign);
                const signature = sig.sign();

                // Format the signed message
                const signedMessage = `Message: ${message}\nTimestamp: ${timestamp}\nSignature: ${signature}`;
                
                document.getElementById('signed-message').value = signedMessage;
                showMessage('sign-success');
                showMessage('sign-error', false);
            } catch (error) {
                console.error('Signing failed:', error);
                showMessage('sign-success', false);
                showMessage('sign-error');
            }
        }

        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            element.select();
            document.execCommand('copy');
            
            const originalBg = element.style.backgroundColor;
            element.style.backgroundColor = '#e8f0fe';
            setTimeout(() => {
                element.style.backgroundColor = originalBg;
            }, 200);
        }

        function downloadText(elementId, filename) {
            const text = document.getElementById(elementId).value;
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>