<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSA/ECDSA Key Management and Signing</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsrsasign/10.9.0/jsrsasign-all-min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 2rem auto;
            padding: 1rem;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .section {
            margin: 1.5rem 0;
            padding: 1.5rem;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }
        textarea, input[type="text"] {
            width: 100%;
            padding: 0.5rem;
            margin: 0.5rem 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
        }
        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            margin: 0.5rem 0.5rem 0.5rem 0;
        }
        button:hover {
            background: #0052a3;
        }
        .success {
            color: #28a745;
            padding: 0.5rem;
            margin: 0.5rem 0;
            display: none;
        }
        .error {
            color: #dc3545;
            padding: 0.5rem;
            margin: 0.5rem 0;
            display: none;
        }
        .file-input {
            margin: 1rem 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>RSA/ECDSA Key Management and Signing</h2>
        
        <div class="section">
            <h3>Step 1: Load and Encrypt Private Key</h3>
            <div class="file-input">
                <label for="private-key-file">Load Private Key (PEM):</label><br>
                <input type="file" id="private-key-file" accept=".pem" onchange="loadPrivateKeyFile()">
            </div>
            <div class="file-input">
                <label for="public-key-file">Load Public Key (PEM):</label><br>
                <input type="file" id="public-key-file" accept=".pem" onchange="loadPublicKeyFile()">
            </div>
            <button onclick="encryptPrivateKey()">Generate AES Key and Encrypt</button>
            
            <h4>Generated AES Key (save this securely):</h4>
            <input type="text" id="aes-key-display" readonly>
            <button onclick="copyToClipboard('aes-key-display')">Copy AES Key</button>
            
            <h4>Encrypted Private Key:</h4>
            <textarea id="encrypted-private-key" rows="4" readonly></textarea>
            <button onclick="copyToClipboard('encrypted-private-key')">Copy Encrypted Key</button>
            <button onclick="downloadText('encrypted-private-key', 'private_key.ciphered.pem')">Download</button>
            <div id="encrypt-success" class="success">Encryption successful!</div>
            <div id="encrypt-error" class="error">Encryption failed. Please check your input.</div>
        </div>

        <div class="section">
            <h3>Step 2: Load and Decrypt Private Key</h3>
            <div class="file-input">
                <label for="encrypted-key-file">Load Encrypted Private Key:</label><br>
                <input type="file" id="encrypted-key-file" accept=".pem" onchange="loadEncryptedKeyFile()">
            </div>
            <textarea id="encrypted-key-input" rows="4" placeholder="Or paste encrypted private key here"></textarea>
            <button onclick="autoloadEncryptedKey()">Or ... Autoload Encrypted Key from private_key.ciphered.pem</button>
            
            <br>
            <label for="aes-key">Enter AES Key:</label>
            <input type="text" id="aes-key" placeholder="Enter your AES key">
            <button onclick="decryptAndVerify()">Decrypt and Verify</button>
            <div id="decrypt-success" class="success">Decryption and verification successful!</div>
            <div id="decrypt-error" class="error">Decryption failed or verification failed. Please check your keys.</div>
        </div>

        <div class="section">
            <h3>Step 3: Sign Message</h3>
            <label for="message">Enter Message to Sign:</label>
            <textarea id="message" rows="4" placeholder="Enter your message here"></textarea>
            <button onclick="signMessage()">Sign Message</button>
            
            <h4>Signed Message:</h4>
            <textarea id="signed-message" rows="6" readonly></textarea>
            <button onclick="copyToClipboard('signed-message')">Copy Signed Message</button>
            <button onclick="downloadText('signed-message', 'permit.signed.txt')">Download</button>
            <div id="sign-success" class="success">Message signed successfully!</div>
            <div id="sign-error" class="error">Signing failed. Please ensure private key is loaded.</div>
        </div>
    </div>

    <script>
        let currentPrivateKey = null;
        let currentPublicKey = null;
        let keyType = null; // 'RSA' or 'ECDSA'

        function showMessage(elementId, show = true) {
            const element = document.getElementById(elementId);
            element.style.display = show ? 'block' : 'none';
            if (show) {
                setTimeout(() => { element.style.display = 'none'; }, 3000);
            }
        }

        function generateSecureRandomBytes(length) {
            return CryptoJS.lib.WordArray.random(length);
        }

        async function loadPrivateKeyFile() {
            const fileInput = document.getElementById('private-key-file');
            const file = fileInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const pemContent = e.target.result;
                        // Determine key type
                        if (pemContent.includes('BEGIN RSA PRIVATE KEY')) {
                            keyType = 'RSA';
                        } else if (pemContent.includes('BEGIN EC PRIVATE KEY')) {
                            keyType = 'ECDSA';
                        } else {
                            throw new Error('Unsupported key type');
                        }
                        currentPrivateKey = pemContent;
                    } catch (error) {
                        console.error('Error loading private key:', error);
                        showMessage('encrypt-error');
                    }
                };
                reader.readAsText(file);
            }
        }

        async function loadPublicKeyFile() {
            const fileInput = document.getElementById('public-key-file');
            const file = fileInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    currentPublicKey = e.target.result;
                };
                reader.readAsText(file);
            }
        }

        async function encryptPrivateKey() {
            try {
                if (!currentPrivateKey || !currentPublicKey) {
                    throw new Error("Please load both private and public keys");
                }

                // Generate a secure random 256-bit AES key
                const aesKey = generateSecureRandomBytes(32);
                const aesKeyBase64 = aesKey.toString(CryptoJS.enc.Base64);
                const iv = generateSecureRandomBytes(16);

                // Encrypt the private key
                const encrypted = CryptoJS.AES.encrypt(currentPrivateKey, aesKey, {
                    iv: iv,
                    padding: CryptoJS.pad.Pkcs7,
                    mode: CryptoJS.mode.CBC
                });

                // Combine IV and ciphertext
                const encryptedMessage = iv.concat(encrypted.ciphertext).toString(CryptoJS.enc.Base64);

                document.getElementById('aes-key-display').value = aesKeyBase64;
                document.getElementById('encrypted-private-key').value = encryptedMessage;

                showMessage('encrypt-success');
                showMessage('encrypt-error', false);
            } catch (error) {
                console.error('Encryption failed:', error);
                showMessage('encrypt-success', false);
                showMessage('encrypt-error');
            }
        }

        async function loadEncryptedKeyFile() {
            const fileInput = document.getElementById('encrypted-key-file');
            const file = fileInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    document.getElementById('encrypted-key-input').value = e.target.result;
                };
                reader.readAsText(file);
            }
        }

        async function autoloadEncryptedKey() {
            try {
                const response = await fetch('private_key.ciphered.pem');
                const text = await response.text();
                document.getElementById('encrypted-key-input').value = text;
            } catch (error) {
                console.error('Failed to autoload encrypted key:', error);
                showMessage('decrypt-error');
            }
        }

        async function decryptAndVerify() {
            try {
                const aesKeyBase64 = document.getElementById('aes-key').value;
                const encryptedKeyBase64 = document.getElementById('encrypted-key-input').value;

                const aesKey = CryptoJS.enc.Base64.parse(aesKeyBase64);
                const encryptedBytes = CryptoJS.enc.Base64.parse(encryptedKeyBase64);

                const iv = CryptoJS.lib.WordArray.create(encryptedBytes.words.slice(0, 4));
                const ciphertext = CryptoJS.lib.WordArray.create(encryptedBytes.words.slice(4));

                const decrypted = CryptoJS.AES.decrypt({ ciphertext }, aesKey, {
                    iv: iv,
                    padding: CryptoJS.pad.Pkcs7,
                    mode: CryptoJS.mode.CBC
                });

                const decryptedKey = decrypted.toString(CryptoJS.enc.Utf8);
                const privateKey = KJUR.KEYUTIL.getKey(decryptedKey);
                const publicKey = KJUR.KEYUTIL.getKey(currentPublicKey);

                if (!KJUR.KEYUTIL.compareKey(privateKey, publicKey)) {
                    throw new Error('Private key and public key do not match');
                }

                showMessage('decrypt-success');
                showMessage('decrypt-error', false);
            } catch (error) {
                console.error('Decryption or verification failed:', error);
                showMessage('decrypt-success', false);
                showMessage('decrypt-error');
            }
        }

        async function signMessage() {
            try {
                const message = document.getElementById('message').value;
                const privateKey = KJUR.KEYUTIL.getKey(currentPrivateKey);
                const sig = new KJUR.crypto.Signature({ alg: 'SHA256with' + keyType });
                sig.init(privateKey);
                sig.updateString(message);
                const signature = sig.sign();

                document.getElementById('signed-message').value = signature;

                showMessage('sign-success');
                showMessage('sign-error', false);
            } catch (error) {
                console.error('Signing failed:', error);
                showMessage('sign-success', false);
                showMessage('sign-error');
            }
        }

        function copyToClipboard(elementId) {
            const copyText = document.getElementById(elementId);
            copyText.select();
            document.execCommand('copy');
        }

        function downloadText(elementId, filename) {
            const text = document.getElementById(elementId).value;
            const element = document.createElement('a');
            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            element.setAttribute('download', filename);

            element.style.display = 'none';
            document.body.appendChild(element);

            element.click();

            document.body.removeChild(element);
        }

        // Autoload the public key on page load
        window.onload = function() {
            fetch('public_key.pem')
                .then(response => response.text())
                .then(text => {
                    currentPublicKey = text;
                })
                .catch(error => console.error('Failed to load public key:', error));
        };
    </script>
</body>
</html>
