<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>A10 Autocomplete & Autocorrect</title>
<link rel="stylesheet" type="text/css" href="../styles/styles.css">

</head>
<body>
  <div class="container">
    <h1>A10 Form</h1>
    <div id="loadingMessage" class="loading">Loading word list...</div>
    <div class="form-group" id="formGroup" style="display: none;">
      <label for="a10Input">Enter Text:</label>
      <div class="autocomplete">
        <textarea
          id="a10Input"
          placeholder="Start typing..."
          aria-label="Enter text"
          role="textbox"
          aria-multiline="true"
          disabled
        ></textarea>
        <div id="suggestion" class="suggestion"></div>
        <div id="error" class="error"></div>
      </div>
      <button id="copyButton" class="button" disabled>Copy to Clipboard</button>
      <div id="status" class="status"></div>
    </div>
  </div>

  <script>
   
 class AutocompleteAutocorrect {
  constructor(input, wordList) {
    this.input = input;
    this.wordList = wordList;
    this.currentFocus = -1;
    this.listId = 'suggestion-list';
    this.suggestionDiv = document.getElementById('suggestion');
    this.errorDiv = document.getElementById('error');
    this.copyButton = document.getElementById('copyButton');
    this.statusDiv = document.getElementById('status');
    this.lastWord = '';
    this.setupEventListeners();
    this.debounceTimer = null;
  }

  setupEventListeners() {
    this.input.addEventListener("input", () => {
      clearTimeout(this.debounceTimer);
      this.debounceTimer = setTimeout(() => this.handleInput(), 150);
    });

    this.input.addEventListener("keydown", (e) => this.handleKeyDown(e));
    document.addEventListener("click", (e) => this.closeAllLists(e.target));
    
    this.copyButton.addEventListener("click", () => this.copyToClipboard());
  }

  // Add missing methods
  findMatches(currentWord) {
    return this.wordList.filter(word => 
      word.toLowerCase().startsWith(currentWord.toLowerCase())
    );
  }

  findClosestMatch(currentWord) {
    let minDistance = Infinity;
    let closestWord = null;

    for (const word of this.wordList) {
      const distance = this.levenshteinDistance(currentWord.toLowerCase(), word.toLowerCase());
      if (distance < minDistance) {
        minDistance = distance;
        closestWord = word;
      }
    }

    // Only return a suggestion if the distance is reasonable
    return minDistance <= 3 ? closestWord : null;
  }

  levenshteinDistance(a, b) {
    const matrix = [];

    for (let i = 0; i <= b.length; i++) {
      matrix[i] = [i];
    }

    for (let j = 0; j <= a.length; j++) {
      matrix[0][j] = j;
    }

    for (let i = 1; i <= b.length; i++) {
      for (let j = 1; j <= a.length; j++) {
        if (b.charAt(i - 1) === a.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }

    return matrix[b.length][a.length];
  }

  handleKeyDown(e) {
    const list = document.getElementById(this.listId);
    if (!list) return;
    
    const items = list.getElementsByTagName("div");
    
    if (e.keyCode === 40) { // down arrow
      this.currentFocus++;
      this.addActive(items);
    } else if (e.keyCode === 38) { // up arrow
      this.currentFocus--;
      this.addActive(items);
    } else if (e.keyCode === 13) { // enter
      e.preventDefault();
      if (this.currentFocus > -1) {
        if (items) items[this.currentFocus].click();
      }
    }
  }

  addActive(items) {
    if (!items) return;
    this.removeActive(items);
    if (this.currentFocus >= items.length) this.currentFocus = 0;
    if (this.currentFocus < 0) this.currentFocus = (items.length - 1);
    items[this.currentFocus].classList.add("autocomplete-active");
  }

  removeActive(items) {
    for (let i = 0; i < items.length; i++) {
      items[i].classList.remove("autocomplete-active");
    }
  }

  closeAllLists(element) {
    const lists = document.getElementsByClassName("autocomplete-items");
    for (const list of lists) {
      if (element !== list && element !== this.input) {
        list.parentNode.removeChild(list);
      }
    }
  }

  clearMessages() {
    if (this.suggestionDiv) this.suggestionDiv.style.display = "none";
    if (this.errorDiv) this.errorDiv.textContent = "";
  }
}

// Modified initialization code
function init() {
  const loadingMessage = document.getElementById('loadingMessage');
  const formGroup = document.getElementById('formGroup');
  const a10Input = document.getElementById("a10Input");
  const copyButton = document.getElementById("copyButton");

  async function loadWordList() {
    try {
      const response = await fetch("../data/wordlist.small.txt");
      if (!response.ok) {
        throw new Error('Network response was not ok: ' + response.statusText);
      }
      const data = await response.text();
      return data.split('\n')
        .map(word => word.trim())
        .filter(word => word.length > 0);
    } catch (error) {
      throw new Error(`Failed to load word list: ${error.message}`);
    }
  }

  async function initialize() {
    try {
      const words = await loadWordList();
      
      // Update UI elements
      loadingMessage.style.display = 'none';
      formGroup.style.display = 'block';
      a10Input.disabled = false;
      copyButton.disabled = true;
      
      // Initialize autocomplete
      new AutocompleteAutocorrect(a10Input, words);
    } catch (error) {
      console.error('Error loading word list:', error);
      loadingMessage.textContent = error.message + ' Please refresh the page.';
      loadingMessage.style.color = '#dc3545';
    }
  }

  initialize();
}

document.addEventListener('DOMContentLoaded', init);


  </script>
</body>
</html>